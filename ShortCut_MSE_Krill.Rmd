---
title: "![](logoUMAG.jpg){width=4cm}"
output:
  pdf_document:
    includes:
      before_body: titulo.sty
    keep_tex: yes
    number_sections: no
    toc: true
    toc_depth: 3
bibliography: SA_krill.bib
csl: apa.csl
link-citations: yes
linkcolor: blue
indent: no
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhf{}
- \lfoot[\thepage]{}
- \rfoot[]{\thepage}
---


```{=tex}
\fontsize{10}{18}
\selectfont
```

```{r setup, include=FALSE, message=F}
rm(list = ls())
options(bitmapType = "cairo") 
#XQuartz is a mess, put this in your onload to default to cairo instead (https://github.com/tidyverse/ggplot2/issues/2655)
# Lo mapas se hacen mas rapido
# solo para IOs
```


```{r setup, echo = FALSE, warning = FALSE, message = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "  ",
  fig.align = 'center',
  cache = FALSE,
  tidy.opts = list(width.cutoff = 55),
  tidy = TRUE
)

knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$linewidth)) {
    x <- knitr:::split_lines(x)
    if (any(nchar(x) > n)) x <- strwrap(x, width = n)
    x <- paste(x, collapse = '\n')
  }
  x
})
```

\pagebreak

# INTRODUCTION

This work presents a Management Strategy Evaluation (MSE) framework applied to Antarctic krill (*Euphausia superba*) in the Western Antarctic Peninsula (WAP), representing the first implementation of an MSE based on an integrated stock assessment model using `SS3` (Stock Synthesis 3) as the operating model for this species.

The simulation framework is structured following the general principles developed under the ICES MSE BlackSteam Working Group, and it draws heavily on methodologies established in the **FLR** (Fisheries Library in R) framework. The MSE is built upon FLR packages such as `FLCore`, `FLAssess`, and `FLasher`, which provide the computational tools and object-oriented architecture to implement and evaluate management strategies in a reproducible and flexible way.

The objective of this MSE is to test the performance of alternative Harvest Control Rules (HCRs) in meeting predefined conservation and yield objectives under uncertainty in stock dynamics and observation processes. The operating model (OM) represents the "true" krill population dynamics, incorporating recruitment variability, environmental forcing, and stochasticity in both biological and fishery processes. The estimation model (EM) simulates the application of a stock assessment under realistic monitoring and assessment error, informing annual catch limits.

By adopting this approach, the study provides a transparent and policy-relevant evaluation of candidate HCRs for krill fisheries in the WAP, in this case, the currently catch limit. This research is developed within an academic framework and aims to provide a methodological contribution to the ongoing discussions regarding the revision of krill new management strategy under CCAMLR. By demonstrating the feasibility and utility of implementing a Management Strategy Evaluation using an SS3-based operating model and tools from the FLR framework, this study offers a scientifically robust foundation to support the development of adaptive, ecosystem-informed harvest strategies aligned with the precautionary and ecosystem-based principles of CCAMLR.

All model code process and simulation tools will made openly available to the scientific community, encouraging transparency, reproducibility, and constructive feedback to refine and strengthen this approach through collaborative development.



Load packages


```{r, message=FALSE,warning=FALSE}
# Load
library(ggplot2)
library(FLCore)
library(ggplotFL)
library(mse)
library(FLRef)
library(ggpubr)
library(mseviz)
library(r4ss)
library(doParallel)
library(here)
library(ss3sim)
library(kableExtra)
```

# Short-Cut MSE for Harvest Control Rule (HCR) in krill 


Different to Management Strategy Evaluation (MSE) simulation design (Punt et al. 2017), the MSE `shortcut` approach omits the step of the annual updating of the estimation model (assessment) in the feedback control. Instead, it emulates an annual update of the benchmark assessment model by passing outcomes ($SSB$ and $F$ or equivalents) from the 'true' age-structured dynamics of the operating model (OM), with assessment error, to the harvest control rule (HCR) and catch implementation system.

The HCRs are implemented using a simulated feedback control loop between the implementation system and the operating model, where the implementation system translates the emulated assessment outcome into the Total Allowable Catch (TAC) advice. The feedback control loop accounts for the lag between the last year of data used in the assessment and the implementation year of catch advice ($C_{adv}$).

For Antarctic krill in the Western Antarctic Peninsula (WAP), the implementation system of the harvest control rule is based on the assumption that advice is given for year $y+1$ based on an assessment completed in year $y$, using data available up to year $y-1$. The implementation of the derived $C_{adv}$ through the HCR therefore requires projection of stock dynamics via a short-term forecast. To do this, numbers-at-size (or -age) are projected through the year of assessment. Parameters such as recruitment, natural mortality ($M$), weight-at-size, and maturity are set as the mean of the last three years. A projection based on a fixed exploitation rate or fishing mortality corresponding to the last year ($y-1$) is used through to the implementation year ($y+1$).

The goal of this application is to test the robustness of the current harvest control rule used by CCAMLR for krill, which consists of a fixed TAC of 145,000 tonnes per year. The shortcut MSE approach facilitates this by reducing computational complexity and avoiding the need for annual full assessments, while still capturing feedback effects between advice and stock dynamics. Here, the MSE short-cut approach is implemented using the tools available in the Fisheries Library for R (FLR; Kell et al., 2007; [FLR Library](https://flr-project.org/) 


## Glossary

The following glossary summarizes key HCR parameters and associated target and limit reference points
that are considered for tuning the candidate HCRs to optimise the trade-offs between maximising fishing
opportunity and risk:


+ $F_{MSY}$: target reference point for fishing mortality at Fmsy (or its proxy), (e.g. $F_{first year}$)

+ $B_{MSY}$: the average biomass around which the biomass fluctuated when fishing at $F_{MSY}$ or its proxy (e.g. $B_{35}$)

+ $B_{lim}$: a deterministic biomass limit reference point below which a stock is considered to have reduced reproductive capacity. Here $B_{lim}$ was set to $0.25B_{tgt}$ 

+ $B_{pa}$: a precautionary biomass reference point set with high probability that biomass is above $B_{lim}$, which acts as a safety margin below which the risk of reduced reproductive capacity is increasing. When the biomass is estimated to be above Bpa, the stock is considered to be within safe biological limits in terms of its reproductive capacity. 

+ $C_{adv}$: advised catch as output of the management procedure 

+ $B_{trigger}$: biomass trigger point of the HCR, specified as change point of biomass below which fishing mortality reduced relative to Ftgt. Btrigger is typically specified as ratio to $B_{MSY}$.


# METHODOLOGY


## Operating Model developing

Build `FLStock` object.


```{r, eval=TRUE}
dir1 <- here("s1.4")
run = "krill.stock.wAP"
stk = window(ss3om::readFLSss3(dir1))
stk = simplify(stk)
# Fill NAs
stk@m.spwn[] = 0
stk@harvest.spwn[] = 0 
sr = ss3om::readFLSRss3(dir1,run)
stk@name = run
stk@desc = "2024, CCAMLR, SS3"
out = ss3om::readOutputss3(dir1)
#save(stk, sr, out, file = "base.model1.4.RData")
```


This code block initiates the setup of the operating model by reading and simplifying the stock and recruitment objects generated by the SS3 model. The working directory for the model outputs is specified (`dir1 <- here("s1.4")`), pointing to the folder that contains the SS3 output files. The main stock object (`stk`) is read using `ss3om::readFLSss3()`, and is then simplified using the `simplify()` function to remove unnecessary complexity. Missing values for the timing of spawning in both natural mortality and harvest are set to zero (`m.spwn[] = 0`, `harvest.spwn[] = 0`) to ensure consistency and completeness of the object. The recruitment object (`sr`) is read using `ss3om::readFLSRss3()`, and metadata for the stock object is updated for documentation purposes, indicating the model name and description, including year and source. Finally, all additional output files from SS3 (e.g., biomass, selectivity, fishing mortality) are read and stored in `out` using `ss3om::readOutputss3()`. This prepares the objects necessary for subsequent use in Management Strategy Evaluation (MSE) simulations.


```{r, eval=FALSE}
run = "krill.stock.wAP"
load(file=file.path("rdata",paste0(run,".rdata")),verbose = T)
stka = stk
```

## Retune Stock-Recruitment

```{r}
# Extract SR pars
s = params(sr)[[1]]
R0 = params(sr)[[2]]
B0 = params(sr)[[3]]

# single sex
sr1 = srrTMB(as.FLSR(stka,
                     model=bevholtSV),
             spr0=mean(spr0y(stk)),
             r0.pr=c(R0,0.0001),
             s=s,
             s.est=F)
```

First, key parameters of the SR function are extracted from the recruitment object (`sr`), including `s` (shape or steepness parameters), `R0` (unfished recruitment), and `B0` (unfished spawning biomass). Then, a new SR relationship object (`sr1`) is created using the `srrTMB` function, which fits a Beverton-Holt stock-recruitment model with stochastic variation (denoted by the `bevholtSV` model). The input stock-recruitment data is converted to an `FLSR` object using `as.FLSR(stka)`. The `spr0` argument sets the unfished spawning potential ratio, calculated as the mean over years from the stock object (`stk`). The initial recruitment parameter `r0.pr` is initialized with `R0` and a small variance (0.0001). The `s` parameter is fixed (`s.est=F`) indicating it will not be estimated in this fit.

This retuning step ensures that the recruitment dynamics incorporated in the model reflect updated or refined parameter estimates for more realistic population projections in subsequent MSE simulations (Figure \@ref(fig:sr)).


```{r sr , message=FALSE,warning=FALSE,fig.width=6,fig.height=4, fig.cap = paste0("Comparison of stock stock-recruitment function from ss3 and retuned single-sex with FLSRTMB ") }
plotsrs(FLSRs(ss3=sr,
              sr=sr1))
```
Check that the `fbar` range is consistent with `ss.starter` input.

```{r}
range(stk)
```


Figure \@ref(fig:mainvar) displays key krill population and fishery variables for Management Strategy Evaluation (MSE), showing Spawning Stock Biomass (SSB) ranging from 0.00 to 0.12 (likely million tons), annual catch levels from 0 to 1.5 billion individuals, fishing mortality (F) for years 1990-2020, and recruitment (Rec) data across the same period, with the x-axis representing years on an unusual scale up to 160,000. The visualization illustrates relationships between reproductive biomass, harvest levels, fishing pressure, and population replenishment, enabling assessment of trade-offs between conservation goals (maintaining SSB) and fishery targets (sustaining catches) under different management scenarios in Antarctic krill fisheries.


```{r mainvar , message=FALSE,warning=FALSE,fig.height=6,fig.width=8, fig.cap = paste0("Seasonal  stock trajectories") }
plot(stk,
     metrics=list(SSB=function(x)unitSums(ssb(x)[,,,1]),
                  F=function(x)fbar(x),
                  Catch=function(x)catch(x),
                  Rec=function(x)unitSums(rec(x))))+
  theme_bw()+
  ylab("F")+
  xlab("Year")+
  facet_wrap(~qname,
             scales="free_y")
```

## Plot SS3 Stock Dynamics

Figure \@ref(fig:trayec)

```{r trayec, fig.height=5,fig.width=7, fig.cap = paste0("Stock assessment trajectories at age")}
plotdyn(stk)+
  theme_bw()+
  scale_color_viridis_d(option="G")
```

\newpage 

Figure \@ref(fig:trayec2)

```{r trayec2, fig.height=5,fig.width=7, fig.cap = paste0("Stock biology trajectories at age")}

plotbioyr(stk)+
  ggtitle(paste0(stk@name))+
  scale_color_viridis_d(option="G")

```

\newpage 

Figure \@ref(fig:trayec3)

```{r trayec3, fig.height=6, fig.cap = paste0("Annual stock quanties at age")}
plotbioage(stk)+
  theme(legend.position = "none")+
  scale_color_viridis_d(option="G")
```

\pagebreak

## Consistency checks using backtesting


```{r}
set.seed(123)
```

Get bias adjusted recruitment deviations from ss3 model.

The first code block processes recruitment deviations from an SS3 model output, applying bias adjustment to account for log-normal error structure. It then simplifies a seasonal stock assessment model (`stk`) into an annual, sex-structured format (`stka`) by aggregating seasonal data using weighted averages. If the original stock has multiple seasons, it converts the stock-recruitment relationship (`sr`) into an annual version (`sra`), ensuring compatibility with the simplified model. This step is crucial for MSE as it reduces computational complexity while preserving key biological dynamics.  

The second block extracts predicted recruitment (`pred_recr`) and bias-adjusted deviations from the SS3 output, converting them into an `FLQuant` object for use in FLR (Fisheries Library in R). The recruitment deviations are adjusted by subtracting bias and accounting for process error (`sigR`). If the stock is sex-structured (two units: F/M), the recruitment values are expanded accordingly. This ensures that recruitment variability is realistically incorporated into projections, maintaining the stock’s sex-specific dynamics when required.  

The third block performs forward simulations (`fwd`) to test the stock’s response under two management scenarios: (1) fixed catch (`testC`) and (2) fixed fishing mortality (`testF`). These projections use the adjusted recruitment (`recs`) and apply historical catch or F levels (excluding the first year to avoid initialization bias). This step evaluates how the stock would perform under different harvest strategies, a core component of MSE to compare trade-offs between yield and sustainability. The results help assess whether the model behaves as expected before full MSE simulations are run.

```{r}
if(dims(stk)$season>1){
stka = simplify(stk,'season',weighted = TRUE,harvest=TRUE)

discards.wt(stka) = stock.wt(stka)
stka@discards  =  computeDiscards(stka)
# Make annual sra
sra = sr
params(sra) = FLPar(an(sr@params[,1]),params=rownames(sr@params))
} else {
sra = sr1
stka = stk
}
```


```{r}
yrs = an(dimnames(stk)$year)
recruit = out$recruit[out$recruit$Yr%in%yrs,]
dms <- list(year = yrs)
sigR =  mean(an(out$sigma_R_info[1:2,"SD_of_devs_over_sigma_R"])) # Realised sigR
residuals <- FLQuant(exp(recruit$dev - 0.5 * recruit$biasadjuster *sigR^2), 
        dimnames = c(age = 0, dms), units = "")
recs = FLQuant(recruit$pred_recr, dimnames = c(age = 0, dms), units = "")


if (dims(stk)$unit == 2) recs <- expand(recs, unit = c("F", "M"))

```

```{r}
if (dims(stka)$unit == 3)
yrs = an(dimnames(stka)$year)
testC = fwd(stka,sr=recs[,ac(yrs[-1])],
  control=fwdControl(year=yrs[-1], value=(unitSums(catch(stka)[, ac(yrs[-1])])),
  quant="catch"))

testF = fwd(stka, sr=recs[,ac(yrs[-1])],
  control=fwdControl(year=yrs[-1], value=unitMeans(fbar(stka)[, ac(yrs[-1])]),
  quant="fbar"))
```

Figure \@ref(fig:hc1) generates a comparative diagnostic plot of three key model outputs—the original SS3-derived operating model (`ss3om=stka`), a catch-constrained forward projection (`backtestC=testC`), and an F-constrained projection (`backtestF=testF`)—to validate model consistency and performance before full MSE implementation. By comparing trajectories, this visualization helps identify potential structural mismatches (e.g., recruitment deviations, unrealistic biomass declines under catch limits) and ensures the simplified, sex-structured OM reliably replicates expected dynamics under different management scenarios, serving as a critical pre-MSE quality check to confirm the model's robustness for subsequent strategy evaluations.


```{r hc1, message=FALSE,warning=FALSE,fig.width=9,fig.height=7, fig.cap = paste0("Comparison of stock trajectories from ss3om and a backtest under the same Fbar") }

plot(window(FLStocks(ss3om=stka,
                     backtestC=testC,
                     backtestF=testF)))+
  theme_bw()+
  facet_wrap(~qname,scale="free_y")
```

(Note that minor deviations are likely due to difficulties in precisely adjusting the rec devs with bias correction)

## Estimate candidate reference points in krill fishery

Now, we obtain key biological reference points for krill fishery management, using outputs from an SS3 stock assessment model (stored in `out`). First, it calculates recruitment deviations (`maindevs`) and their autocorrelation (`rho`) along with process error (`sigmaR`). 

For MSY-based reference points, it extracts virgin SSB (unfished biomass) and scales it to estimate `Bmsy` (75% of virgin SSB), while `Fmsy` is taken either as a fixed low value (0.001) or derived from first F (e.g., `F_1997`) like assumtion of virginal condition. MSY is obtained directly from SS3 output, along with relative biomass (`B_MSY/SSB_unfished`). Uncertainty is quantified via CVs for SSB and F in the assessment year. The tuning grid defines precautionary thresholds: Blim, Bpa, and Btrigger are set at 20% of virgin SSB, while Feq (equilibrium F) uses recent fishery levels (F_2020) or a fixed value (0.018). The note highlights a discrepancy where the SS3-derived Fmsy (0.001) is lower than the empirical Feq (0.018), suggesting that the harvest control rule may be conservatively restricting fishing pressure below Btrigger, keeping realized F lower than the theoretical MSY level. These reference points form the basis for evaluating management strategies in subsequent MSE runs.

```{r}
# Main recdevs
recyrs = recruit$Yr[recruit$era =="Main"]
maindevs = unitSums(residuals[,ac(recyrs)])
rho = cor(maindevs [,-1],maindevs [,-length(maindevs)])
sigmaR = out$sigma_R_in

rho 
sigmaR

# MSY refpts
Bmsy <- out$derived_quants$Value[out$derived_quants$Label=="SSB_Virgin"]*0.75
#Fmsy <- 0.001
#or
Fmsy <- out$derived_quants$Value[out$derived_quants$Label=="F_1997"] # to star tt fishery
MSY <- out$derived_quants$Value[out$derived_quants$Label=="Dead_Catch_MSY"]
out$derived_quants$Value[out$derived_quants$Label=="B_MSY/SSB_unfished"]
# Short cut devs
ay = out$endyr # assessment year
SSBcv <- out$derived_quants$StdDev[out$derived_quants$Label==paste0("SSB_",ay)]/
  out$derived_quants$Value[out$derived_quants$Label==paste0("SSB_",ay)]

Fcv <- out$derived_quants$StdDev[out$derived_quants$Label==paste0("F_",ay)]/
  out$derived_quants$Value[out$derived_quants$Label==paste0("F_",ay)]

```

# Tuning grid

```{r}
#Blim=145000
Blim <- out$derived_quants$Value[out$derived_quants$Label=="SSB_Virgin"]*0.20

#Bpa=620000
Bpa <- out$derived_quants$Value[out$derived_quants$Label=="SSB_Virgin"]*0.20

#Btri.eq = 620000
Btri.eq <- out$derived_quants$Value[out$derived_quants$Label=="SSB_Virgin"]*0.20

#Feq =0.001  
#or 
Feq <- out$derived_quants$Value[out$derived_quants$Label=="F_2020"] #or Fstatus quo  (2020)
Fp05.eq =0.018

#or 
# > Fmsy # SS3
# [1] 0.001
# > Feq
# [1] 0.018
```

> Note that in this case the "true" $F_{MSY}$ as the property of the model is smaller than the $F_{MSY}$ derived from `EQsim`. This may be explained by the presence of the harvest control rule resulting in effective taking place, on average, below Btrigger.

```{r}
Fmsy # SS3
Feq
```

Function to find $B$ for $F$ at equilibrium

```{r}
fwdB4F = function(stock,sr,Fs=0.2,nfy=30){
    if (class(stock) == "FLStockR") {
      stock = as(stock, "FLStock")
    }
    fyrs = (dims(stock)$maxyear + 1):(dims(stock)$maxyear + nfy)
    nfy = length(fyrs)
    stkf = stf(stock, nfy)
    bx = do.call(c, lapply(an(Fs),function(x){
    ictrl = fwdControl(data.frame(year = fyrs, quant =  "fbar", value = x))
    out = fwd(stkf, sr = sr, control = ictrl)
    an(tail(unitSums(ssb(out))))
    }))
    
    data.frame(F=an(Fs),B=bx)
}

```

This function `fwdB4F` calculates the equilibrium biomass (B) corresponding to specific fishing mortality (F) levels for a krill stock. It works by:

1. Converting the input stock to a standard `FLStock` object if needed
2. Projecting the stock forward for 100 years (default) using the stock-recruitment relationship (sr)
3. Applying constant F values (default F=0.2) throughout the projection period
4. Returning the final equilibrium SSB (spawning stock biomass) reached under each F level

Key features:
- Uses FLR's forward projection (fwd) with fixed F control
- Handles multiple F values simultaneously via lapply
- Returns a dataframe linking each F value to its resulting equilibrium B
- Particularly useful for:
  - Deriving F vs B curves
  - Finding biological reference points
  - Testing equilibrium conditions in management strategy evaluation

The function essentially answers: "What long-term biomass level would this stock stabilize at if we fished it constantly at F=X?" This is fundamental for understanding stock dynamics and setting sustainable harvest levels.

```{r}

Fx = c(rev(seq(0.1,1,0.1)))
#Fx = c(rev(seq(0.5,1,0.025)))
Ftgt = FLPar(c(Fmsy,Fx*Feq),
             params=c("Fmsy.om",
                      paste0(Fx,".Feq"))) 
Ftgt
```

```{r,eval=F}
Bftgt = fwdB4F(stka,
               sra,
               Fs=Ftgt,
               nfy=30)
Bftgt
```

```{r, eval=FALSE, echo=FALSE}
save(Fx,
     Ftgt,
     Bftgt,
     file="rdata/ftune.sbr.rdata")
```

```{r,echo=F}
load(file="rdata/ftune.sbr.rdata")
```

```{r}
Ftgt.tune = FLPar(c(Bftgt$F,Bftgt$B),
                  params=c("Fmsy.om",
                           paste0("Feq",Fx),
                           "Bmsy.om",
                           paste0("Bftgt",Fx))) 
```



```{r}
np = an(nrow(Ftgt.tune))
df = data.frame(
Tune = rownames(Ftgt.tune)[1:(np/2)],
Ftgt = round(an(Ftgt.tune)[1:(np/2)],3),
Btrigger = round(Btri.eq,1),
Btgt = round(an(Ftgt.tune)[(np/2+1):np],1),
"xB0" =  round(an(Ftgt.tune)[(np/2+1):np]/B0,3))
df$Btrigger[1] = 0
df$xB0 = round(df$xB0,2)
```

```{r}
kbl(df, 
    format = "latex",
    booktabs = TRUE,
    caption = "Option: Initial tuning grid with EQSIM Btrigger based on Feq tuning") %>%
  kable_styling(latex_options = c("hold_position", "striped"))

```


```{r}
refpts = FLPar(Fmsy=Fmsy,
               Feq=Feq,
               Bmsy=Ftgt.tune["Bmsy.om"],
               #Beq=Ftgt.tune["Bftgt1"],
               Beq=Ftgt.tune["Bftgt0.3"], #cambiar de acuerdo al FLpar object
               Blim = Blim,
               Bpa=Bpa,
               Btrigger=Btri.eq,
               B0=B0,
               R0=R0)

refpts
```
Create `FLStockR` with `@refpts`

```{r}
stkr = FLStockR(stka)
stkr@refpts = refpts
```

Summarize short-cut params

```{r}
spars = FLPar(s=s,
              sigmaR=sigmaR, 
              rho=rho,
              Fcv=Fcv,
              SSBcv=SSBcv)
```

```{r , message=FALSE,warning=FALSE,fig.height=7,fig.width=9, fig.cap = paste0("Status Advice plot  showing stock trajectories of Recruitment, $SSB$, $F$, recruitment and $Yield$") }

plotAdvice(stkr)
```

```{r eval=FALSE}
save(stk,
     stka,
     stkr,
     refpts,
     sr,
     sra,
     spars,
     file="rdata/om.ss3ref.sbr.rdata") 
```

# Set up short-cut MSE

Load OM conditioned to Stock Synthesis

```{r}
load("rdata/om.ss3ref.sbr.rdata",verbose=T)
```


Next set up the MSE horizon

```{r}
# data year
dy <- dims(stka)$maxyear
# FINAL year
fy <- dy+10
# assessment year
ay = dy+1
# intermediate years
iy = ay

```

For illustration the number of iterations are reduced to 100.

```{r}
# NUMBER iterations
it <- 100
```

Subset the 1000 simulated stock iterations to the first 100

```{r}
stki = propagate(stka,
                 it)
```

Generate recruitment 

```{r}
srdevs <- FLCore::rlnormar1(n=it,
                    sdlog=spars["sigmaR"],
                    rho=spars["rho"], 
                    years=seq(dy, fy))
# Sex-structured
if (dims(stki)$unit == 2) srdevs  <- expand(srdevs ,
                                            unit = c("F", "M"))

```


Now construct the `FLom` object from the `mse` package by passing on `FLStock`,`refpts`, `sr` and the method used for foward projections.

```{r}
om <- FLom(stock=stki,
           refpts=refpts, 
           sr=sra,
           projection=mseCtrl(method=fwd.om),
           deviances=srdevs)

om
```

Next add the structure for the future years: average of last 3 years

```{r}
om <- fwdWindow(om, 
                end=fy)
```

Next, a so called observation error is constructed. In the case of the short-cut MSE, it simply holds the "perfect" stock information. For a full MSE with inbuilt estimation model  it would also generate the observations with errors, such a catch-at-age and survey numbers at age for SAM or a4a, or biomass surveys indices and catches for SPicT or JABBA.  

```{r tidy=FALSE}
oem <- FLoem(
  observations=list(stk=stock(om)),
  method=perfect.oem
)
```

However, there is increasing realisation that the assessment estimates are imperfect. Therefore, ICES has implemented procedures to add uncertainty about the key quantities $F$ and $SSB$, where the error on $F$ is specified by a the random error term $Fcv$ and a first order autocorrelation parameter $Fphi$ and the precision of $SSB$ can specified by $SSBcv$ 


Short-cut deviations

```{r tidy=FALSE}
sdevs <- shortcut_devs(om, 
                       Fcv=spars["Fcv"], 
                       Fphi=0.5, 
                       SSBcv=spars["SSBcv"])

```

Finally, the implementation error module `iem` is setup. In this case, with a random catch implementation error of 10\%.

```{r}
iem <- FLiem(method=noise.iem,
  args=list(noise=rlnorm(it, rec(om) %=% 0, 0.1)))
```


```{r,eval=FALSE}
save(om, 
     oem,
     sdevs,
     iem,
     file="rdata/flom.sbr.rda")
```

```{r,echo=FALSE}
load(file="rdata/flom.sbr.rda")
```

## Setting up harvest control rules



This can be effectively implemented ICES advice rule hockey-stick by setting the $B_{trigger}$ to zero, using the `icesControl` function. This function can also take the `SSBdevs` and `Fdevs` that implement the deviations from the SSB and F with aim to account for assessment errors.


Adjusted mse controls for sex-structured stocks

```{r}
shortcut.sa2 <- function(stk, 
                         idx, 
                         SSBdevs=unitSums(ssb(stk)) %=% 1, 
                         args, 
                         tracking, 
                         ...) {
  # DIMS
  y0 <- args$y0
  dy <- args$dy
  ay <- args$ay
  it <- args$it

  # SUBSET oem stock
  stk <- window(stk, end=dy)

  ind <- FLQuants(
    # SSB + devs 
    #><> add unitSums
    ssb=unitSums(ssb(stk)) * window(SSBdevs, 
                                    start=y0, 
                                    end=dy))

  track(tracking, "conv.est", ac(ay)) <- 1

  list(stk=stk, ind=ind, tracking=tracking)
}



tac.is2 <- function(stk, 
                    ctrl,
                    args, 
                    output="catch",
                    recyrs=-2,
  Fdevs=unitMeans(fbar(fut)) %=% 1, 
  dtaclow=NA, 
  dtacupp=NA, 
  fmin=0, 
  reuse=TRUE,
  initac=metrics(stk, output)[, ac(iy - 1)], tracking) { 
  # EXTRACT args
  spread(args)


  # SET control years
  cys <- seq(ay + management_lag, ay + management_lag + frq - 1)

  # PREPARE stk for cys, biology as in last nsqy years
  fut <- fwdWindow(stk, end=cys[length(cys)], nsq=nsqy)

  # PARSE recyrs if numeric
  id <- dimnames(stk)$year

  # COERCE to list
  if(!is.list(recyrs)) {
    recyrs <- list(recyrs)
  }
  
  # PARSE list
  for(i in recyrs) {
    if(is(i, 'character')) {
      id <- id[!id %in% i]
    } else if(all(i < 0)) {
      if(length(i) == 1)
        id <- rev(rev(id)[-seq(abs(i))])
      else
        id <- rev(rev(id)[i])
    } else if(all(i > 0)) {
      id <- rev(rev(id)[seq(abs(i))])
    }
  }

  # SET years to use
  recyrs <- id

  # CHECK recyrs
  if(!all(recyrs %in% dimnames(stk)$year)) {
    stop("'recyrs' cannot be found in input stk")
  }

  # TODO: OTHER rec options
  
 
  # SET GM recruitment from past
  #><> add unitSums()
  gmnrec <- exp(yearMeans(log(unitSums(rec(stk))[, recyrs])))

  # SETUP SRR
  srr <- predictModel(model=rec~a, params=FLPar(a=gmnrec))

  # STORE geomeanrec value 
  track(tracking, "gmrec.isys", ay + management_lag) <- gmnrec

  # ADD F deviances for 1 year

  # reuse = TRUE
  if(isTRUE(reuse) | toupper(reuse) == 'F') {
    ftar <- rep(c(ctrl[1,]$value * Fdevs[, ac(cys[1])]), length(cys))
  # reuse = FALSE
  } else {
    ftar <- c(ctrl$value * Fdevs[, ac(cys)])
  }

  # TRACK Ftarget
  track(tracking, "fbar.isys", cys) <- ftar

  # FORECAST for iyrs and my IF mlag > 0,
  if(management_lag > 0) {
 
    # SET F for intermediate year #><> added unitMeans
    #><> add unitMeans()
  
    fsq <- unitMeans(fbar(stk))[, ac(dy)]

    # TODO: ADD TAC option

    # CONSTRUCT fwd control
    fctrl <- fwdControl(
      # ay as intermediate with Fsq TODO: Other options
      list(year=seq(ay - data_lag + 1, length=management_lag),
        quant="fbar", value=rep(c(fsq), management_lag)),
      # target
      list(year=cys, quant="fbar", value=c(ftar))
    )

  # else only for my
  } else {
    fctrl <- fwdControl(
      list(year=ay + management_lag, quant="fbar", value=ftar))
  }

  # RUN STF ffwd
  fut <- ffwd(fut, sr=srr, control=fctrl)

  # ID iters where hcr set met trigger and F > fmin
  id <- c(tracking[[1]]["decision.hcr", ac(ay)] > 2) &
    c(unitMeans(fbar(fut))[, ac(ay + management_lag)] > fmin)

  # EXTRACT catches
  if(isTRUE(reuse) | toupper(reuse) == "C") {
    TAC <- expand(unitSums(catch(fut))[, ac(cys)[1]], year=seq(length(cys)))
  } else {
    TAC <- unitSums(catch(fut))[, ac(cys)]
  }

  # GET TAC dy / ay - 1
  if(ay == iy)
    prev_tac <- rep(c(initac), length=args$it)
  else
    prev_tac <- c(tracking[[1]]["isys", ac(ay)])

  # APPLY upper and lower TAC limit, if not NA and only for id iters
  if(!is.na(dtacupp)) {
    iter(TAC, id) <- pmin(c(iter(TAC, id)), prev_tac[id] * dtacupp)
  }
  if(!is.na(dtaclow)) {
    iter(TAC, id) <- pmax(c(iter(TAC, id)), prev_tac[id] * dtaclow)
  }

  # CONSTRUCT fwdControl
  # TODO: USE frq here
  ctrl <- fwdControl(lapply(seq(length(cys)), function(x)
    list(year=cys[x], quant=output, value=TAC[,x])))
    
  return(list(ctrl=ctrl, tracking=tracking))
}


```



```{r}
arule <- mpCtrl(list(
  # (est)imation method: shortcut.sa + SSB deviances
  est = mseCtrl(method=shortcut.sa,
    args=list(SSBdevs=sdevs$SSB)),

  # hcr: hockeystick (fbar ~ ssb | lim, trigger, target, min)
  hcr = mseCtrl(method=hockeystick.hcr,
    args=list(lim=0, trigger=0.01, target=Fmsy,
    min=0, metric="ssb", output="fbar")),

  # (i)mplementation (sys)tem: tac.is (C ~ F) + F deviance
  isys = mseCtrl(method=tac.is,
    args=list(recyrs=-2, fmin=0, Fdevs=sdevs$F))
  ))


```

This rule can now be run passing on the `om`, `oem` and `arule` and an additional argument to set the implementation year to 2024.

Note that the default setting assumes 1 year lag between data (reference) year and assessment (reporting) year and that the TAC is implemented the next year. In case the assessment is conducted in 2023, based on data from 2022 and the TAC is implemented for 2024.



(dont Run in krill!!!)
```{r, eval=FALSE, echo=FALSE}
mseargs <- list(iy=dy,
                fy=fy, 
                data_lag=1, 
                management_lag=1, 
                frq=1)

load(file="rdata/mps.ftune.sbr1000.rdata",
     verbose=T)

mp.fixexFmsy = stks$Fmsy.OM

```


```{r,warning=FALSE}
mseargs <- list(iy=dy,
                fy=fy, 
                data_lag=1, 
                management_lag=1, 
                frq=1)

system.time(
run <- mp(om, 
          oem=oem, 
          ctrl=arule, 
          args=mseargs,
          verbose=T)
)

mp.fixexFmsy = run@om@stock

```


```{r fig9, fig.height=7,fig.width=9,warning=FALSE,message=FALSE, fig.cap = paste0("Initial OM and the MSE forecast horizon under a fixed $F_{tgt}$ rule")}

# make FLStocks from om until 2024 (implementation) and the run 
stk.fmsy = FLStocks(stock=window(om@stock,end=dy),
              fixedFmsy=mp.fixexFmsy)

plot(stk.fmsy)+
  facet_wrap(~qname,
             scales="free")+
  theme_bw()+
   geom_vline(xintercept = c(dy),
              linetype=2,col=1)+
  geom_vline(xintercept = c(fy),
             linetype=2,col=4)

```

The `run` can also be appended to the `om` to make a single `FLStockR` object with reference points

```{r}
runR = FLStockR(append(window(om@stock,
                              end=dy),
                       mp.fixexFmsy))
runR@refpts=refpts
```

This allows to quickly evaluate the stock status under a fixed $F_{MSY}$ rule.

It can be seen that despite "perfect" knowledge of the "true" $F_{MSY}$, and fishing pressure is on average $F_{MSY}$, the stock fails to attain biomass levels at $B_{MSY}$ with a relative high risk to fall below $B_{lim}$. This is a well known fact as a result of the lags between data and management and asymetric risks in that exceeding $F_{MSY}$ is more consequential on both $SSB$ and long term yield, then fishing below $F_{MSY}$, In the case of the latter, more biomass is left in the water, which provides increased future reproduction potential and catch opportunity.   

```{r, fig.height=7,fig.width=9,warning=FALSE,message=FALSE, fig.cap = paste0("Stock Status under a fixed $F_{tgt}$ short-cut MSE rule")}
thin = seq(1,it,5)
plotAdvice(iter(runR,thin))+
     geom_vline(xintercept = c(dy),
                linetype=2,col=1)+
    geom_vline(xintercept = c(fy),
               linetype=2,col=4)+
  scale_x_continuous(breaks=seq(1970,3000,5))+
  theme_bw()+
  theme(axis.text.x = element_text(size=8,
                                   angle=90,
                                   vjust=0.5))
```

Even relatively simplified short-cut MSE frameworks provide a powerful to explore alternative HCRs to achieve better trade-off between risks and yield. 

Here, the convential hockey-stick control rule is explored with different ratios of $F_{adv}$/$F_{tgt}$ and $B_{trigger}$/$B_{tgt}$ settings, where the $B_{trigger}$ promts a linear reduction in $F_{adv}$ if $SSB$ falls below it.


```{r , fig.height=5,fig.width=8,warning=FALSE,message=FALSE, fig.cap = paste0("Advice Rule from EQSIM")}

 plotGFCM(fadv = Feq,
          btrigger =Btri.eq,
          bthr = -1,
          ftgt = Feq,
          btgt=df$Btgt[2],
          blim=an(refpts["Blim"]),
          fmin=0,
          bclose=0,
          kobe  =FALSE,
          text=F,
          rel=F,
          xmax=2.5)
```


```{r , fig.height=12,fig.width=8,warning=FALSE,message=FALSE, fig.cap = paste0("Alternative HCR formulations, with $F_{min}=0$ (top) and $F_{min}=0.5F_{tgt}$ (bottom) under different $F_{adv}$ options set at $F_{adv}=F_{adv}$, $F_{adv}=0.8F_{adv}$ and at $F_{adv}=0.7F_{adv}$ from left to right")}

Fadv = c(df$Ftgt) 
Btgt = c(df$Btgt) 
Btri = c(df$Btrigger)

hcrs= Map(function(x,y,z){
p  = plotGFCM(fadv = x,
              btrigger =y,
              ftgt = x,
              btgt=z,
              blim=an(refpts["Blim"]),
              fmin=0,
              bclose=0,
              kobe  =FALSE,
              text=F,
              rel=F)
p = p
return(p)
},
x=Fadv,
y=Btri,
z=Btgt)
# plot ggplot list
ggarrange(plotlist=hcrs,
          nrow=6,
          ncol=4)

```

The same settings can be specified for the new `mps` function in `mse`, which allow to explore variations of the HCR parameters.

The function `combinations` enables to vary more than one parameter at the time. 

```{r}
hcrs =combinations(target=Fadv,
                   trigger=0)
hcrs$trigger = Btri # Overwrite
hcrs

save(om,
     oem,
     arule,
     hcrs,
     df,
     mseargs,
     file="rdata/inpMP.sbr.1000.rdata")
```



These changes in parameters can simply be passed on to the existing `arule` to run the variations with `mps`.  
(dont run in krill!!!)

```{r,eval=FALSE,warning=FALSE}
runs <- mps(om, 
            oem=oem,
            ctrl=arule, 
            args=mseargs,
            hcr=hcrs)
```
this a bypass to run in MAC


```{r}
# Divide en lotes de 100
ni <- length(hcrs$target)  # ← esto es clave

batch_size <- 100  # puedes ajustar este valor según tu iMac
batches <- split(seq(ni), ceiling(seq_along(seq(ni)) / batch_size))


for (b in seq_along(batches)) {
  runs_batch <- foreach(i = batches[[b]]) %dopar% {
    # mismo cuerpo del loop...
  }
  saveRDS(runs_batch, file = paste0("s1.4/runs_batch_", b, ".rds"))
}


runs <- list()
for (i in seq(ni)) {
  hcr = arule
  hcr$hcr@args$target = hcrs$target[i]
  hcr$hcr@args$trigger = hcrs$trigger[i]
  
  runi <- mp(om, oem=oem, ctrl=hcr, args=mseargs, verbose=TRUE, parallel = FALSE)
  runs[[i]] <- runi
}

```

Note the this was run on a linux cluster in parallel
(dont run in MACs !!)

```{r,eval=F}
library(doParallel)
load("rdata/inpMP.sbr.1000.rdata",
     verbose=T)
length(hcrs$target)
# Run in batches

ni = length(hcrs$target)
cl = ni

registerDoParallel(cl)
start = Sys.time()

runs <- foreach(i = seq(ni)) %dopar% {
  
  # set stock index
  hcr = arule
  hcr$hcr@args$target = hcrs$target[i]
  hcr$hcr@args$trigger = hcrs$trigger[i]
  
  runi <- mp(om, 
             oem=oem, 
             ctrl=hcr, 
             args=mseargs,
             verbose=T,
             parallel = FALSE)
  
  return(runi)
} # end of loop 
end = Sys.time()
time = end-start
time
```


```{r}
nfs = length(df$Tune[-1])
tri = c(rep(".Btri.eq",
            each=nfs))
scenarios = c("Fmsy.OM",
              paste0(rep(c(df$Tune[-1]),1),tri))

names(runs) = scenarios

stks = FLStocks(lapply(runs,function(x){
  out = x@om@stock
  out = FLStockR(out)
  out@refpts = om@refpts
  out
}))

stkm = FLStocks(lapply(stks,function(x){
  stockMedians(x)
}))

plotAdvice(stkm)

save(stks,
     file=paste0("rdata/mps.ftune.sbr1000.rdata"))

```


Now combine with the Fixed $F_{MSY}$ run and see if we can do better.

```{r,eval=F}
nfs = length(df$Tune[-1])
tri = c(rep(".Btri.eq",each=nfs))
scenarios = c("Fmsy.OM",paste0(rep(c(df$Tune[-1]),1),tri))

names(runs) = scenarios

```

Save 



An easy way of basic plotting is to extract the `FLStocks` from the list of MSE runs with `lapply`

```{r,eval=F}
stks = FLStocks(lapply(runs,function(x){
  out = (x@om@stock)
  out = FLStockR(out)
  out@refpts = refpts[c(1:5)]
  out
  }))


```



```{r, fig.height=7,fig.width=9,warning=FALSE,message=FALSE, fig.cap = paste0("Initial OM and the MSE forecast horizon under a fixed $F_{tgt}$ rule and 6 HCR hockey-stick scenarios")}

ref = FLStockR(window(stock(om),end=dy))
ref@refpts = refpts
pstks = FLStocks(c(FLStocks(stock=window(ref,end=dy)),
              stks))

plotAdvice(iter(pstks,thin))+facet_wrap(~qname,scales="free")+
  theme_bw()+
  scale_color_manual(values=c("black",
                              ss3col(length(pstks))[-1]))+
  scale_fill_manual(values=c("darkgrey",
                             ss3col(length(pstks))[-1]))+
  geom_vline(xintercept = c(dy),
             linetype=2,col=1)+
    geom_vline(xintercept = c(fy),
               linetype=2,
               col=4)+
  scale_x_continuous(breaks=seq(1900,3000,5))+
  theme(axis.text.x = element_text(size=8, 
                                   angle=90,
                                   vjust=0.5))

```


```{r,eval=FALSE}
save(pstks,
     mseargs,
     file="rdata/shortcut_stks.sbr.rda",
     compress="xz")
```


```{r, fig.height=7,fig.width=9,warning=FALSE,message=FALSE, fig.cap = paste0("Median MSE forecast horizon under a fixed $F_{tgt}$ rule and 6 HCR scenarios")}

medstks = FLStocks(lapply(stks,function(x){
  stockMedians(x)
}))
medref = stockMedians(ref)
pmstks = FLStocks(c(FLStocks(stock=window(medref,end=dy)),
              medstks))

plotAdvice(pmstks)+facet_wrap(~qname,scales="free")+
  scale_color_manual(values=c("black",ss3col(length(pmstks))[-1]))+
  theme_bw()+xlab("Year")+
  geom_vline(xintercept = c(dy),linetype=2,col=1)+
    geom_vline(xintercept = c(fy),linetype=2,col=4)+
  scale_x_continuous(breaks=seq(1900,3000,5))+
  theme(axis.text.x = element_text(size=8, angle=90,vjust=0.5))

```

# Performance Evaluation with adjustment for sex-tructured stocks

## Define Metrics for performance evaluation of sex-structured 

```{r}
metrics <- list(SB = function(x)unitSums(ssb(x)), 
                F = function(x)unitMeans(fbar(x)), 
                C = function(x)unitSums(catch(x)),
                Rec= function(x)unitSums(rec(x)))
```


Define performance statistics - ordered alphabetically

```{r}
stats <- list(
  a.medianFmsy= list(~yearMedians(F/Fmsy), name="F/Fmsy",
    desc="Median annual F/Fmsy"),
  b.medianBmsy = list(~yearMedians(SB/Bmsy), name="B/Bmsy",
    desc="Median annual B/Bmsy"),
  c.medianCmsy = list(~yearMedians(C/MSY), name="Catch/MSY",
    desc="Median Catch/MSY over years"),
  d.aavC = list(~yearMedians(iav(C)), name="AAV",
    desc="Median annual variation in catches"),
  e.riskBlim = list(~apply(iterMeans((SB/Blim) < 1),1,max), 
    name="P3(B<Blim)", desc="Probability that SSB < Blim"),
  f.P80BMSY = list(~apply(iterMeans((SB/(Bmsy * 0.8)) > 1), 1, max),
    name="B>80Bmsy", desc="Probability that SSB > 80% x Bmsy")

)
```  


## Long-term last 25 years (75 years)



Replace deterministic MSY with MSE MSY from a run with the true, fixed $F_{MSY}$ in the  reference points

```{r}
refpts.perf = refpts
refpts.perf = rbind(refpts.perf,
                    FLPar(MSY= median(unitSums(catch(stks$Fmsy.OM[,ac((fy-10):fy)])))))

```


Compute performance metrics

```{r,warning=F,message=F}
perf <- performance(stks,
                    refpts=refpts.perf,
                    metrics=metrics, 
                    statistics=stats, 
                    years=list((fy-10):fy))

```

\pagebreak

## PLOT performance


```{r, fig.height=9,fig.width=8,warning=FALSE,message=FALSE, fig.cap = paste0("Performance: Long-term performance evaluation")}

ncol = length(unique(perf$mp)) 
pbp = plotBPs(perf,
statistics=c("a.medianFmsy","b.medianBmsy","c.medianCmsy", "d.aavC", "e.riskBlim", "f.P80BMSY"), 
size=3, target = c(a.medianFmsy=1,b.medianBmsy=1, c.medianCmsy=1,g.P80BMSY=0.8),
limit= c(e.riskBlim=0.05,c.medianCmsy=0.95),
yminmax = c(0.05, 0.95))+theme_bw()+
facet_wrap(~name,scales = "free_y",ncol=2)+
ggtitle(paste0("Performance: Reference Points"))+
ylab("Performance statistics")+
scale_fill_manual(values=ss3col(ncol))+ # USE FLRef::ss3col
theme(axis.text.x=element_blank())+xlab("Candidates")+ guides(fill= guide_legend(ncol = 1))
pbp

```


\pagebreak

### Performance Table



```{r,echo=F,message=F,warning=F}
dir.create("perftabs",showWarnings = F)

pf = perf[perf$statistic%in%statistic,]
df.pf = aggregate(data~mp+name,pf,mean)
sd.pf = aggregate(data~mp+name,pf,sd)
sd.pf = sd.pf[sd.pf$name=="Catch/MSY",] 
tab.pf = cbind(reshape2::dcast(df.pf,mp~name),SD.Catch=sd.pf$data)
tab.pf[,-1] = round(tab.pf[,-1],3)
# Add Fadv and Btrigger
tab.pf = data.frame(tab.pf,Fadv=df$Ftgt,Btrigger=df$Btrigger)

tab.pf = tab.pf[,c(1,9,7,5,8,2,6,3,4)]
write.csv(tab.pf,file="perftabs/ftune.tab.csv",row.names = F)


knitr::kable(tab.pf,"pipe",
      align ="lccccc",
      caption="Robustness tests of $F_{adv}$ in line with ICES precautionary approach under closed loop simulations with feedback control of assessment advice emulation")


```



\pagebreak

### MSE kobe plot

```{r fig5, fig.height=8,fig.width=10, fig.cap = paste0("MSE kobe plot Advice rules"), warning=FALSE}

kbcex =function(){theme(plot.title = element_text(size=10),
                        legend.key.size = unit(0.3, 'cm'), #change legend key size
                        legend.key.height = unit(0.4, 'cm'), #change legend key height
                        legend.key.width = unit(0.4, 'cm'), #change legend key width
                        legend.text = element_text(size=10)) #change legend text font size
}
kobeMPs(perf,y="a.medianFmsy", x="b.medianBmsy")+
  ylab(expression(F/F[MSY]))+xlab(expression(B/B[MSY]))+ylim(0,2.5)+kbcex()+theme()+guides(fill= guide_legend(ncol = 1))

```

